package egovframework.ghr.zz.system.fileMng;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;
import java.util.zip.ZipOutputStream;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FileOutputStream;

import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Controller;
import org.springframework.util.FileCopyUtils;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.multipart.MultipartHttpServletRequest;
import org.springframework.web.multipart.commons.CommonsMultipartFile;

import com.shaco.EgSubAPI;

import egovframework.com.cmm.service.EgovProperties;
import egovframework.com.utl.file.MultipartFileNamingPolicy;
import egovframework.com.utl.file.PwDefaultFileNamingPolicy;
import egovframework.com.utl.file.SimpleFileVO;

/**
 * 파일 처리 Util 클래스를 정의한다.
 *
 * @author njin
 * @since 2017.09.15
 * @version 1.0
 * @see
 *
 *      <pre>
 * << 개정이력(Modification Information) >>
 *
 *   수정일         수정자      수정내용
 *  ---------            --------       ---------------------------
 *   2017.09.15   njin             최초 생성
 *      </pre>
 */
@Controller
public final class PwZzSystemFileUtil {
    private static final Logger LOGGER = LoggerFactory.getLogger(PwZzSystemFileUtil.class);

    public static List<SimpleFileVO> getFileList(HttpServletRequest request, String jobName, MultipartFileNamingPolicy policy) throws Exception {
		if (jobName == null)
			throw new Exception("파일업로드에 필요한 업무 코드(ex, ZZ, HR, HA) 가 없습니다. ");

		final String biz = jobName;
		final String yyyyMM = new SimpleDateFormat("yyyyMM").format(new Date());
		final String pathSuffix = biz + File.separator + yyyyMM;

		/*
		 * validate request type
		 */
		final MultipartHttpServletRequest multiRequest = (MultipartHttpServletRequest) request;

		/*
		 * process files
		 */
		String uploadPath = EgovProperties.getProperty("Globals.FileStorePath");
		File saveFolder = new File(uploadPath + File.separator + pathSuffix);

		// 디렉토리 생성
		if (!saveFolder.exists() || saveFolder.isFile()) {
			saveFolder.mkdirs();
		}

		List<SimpleFileVO> fileList = new ArrayList<SimpleFileVO>();
		for (String key : multiRequest.getMultiFileMap().keySet()) {

			List<MultipartFile> list = multiRequest.getFiles(key);

			for (int i = 0; i < list.size(); i++) {
				CommonsMultipartFile tempFile = (CommonsMultipartFile) list.get(i);

				LOGGER.debug((i + 1) + ">getContentType : " + tempFile.getContentType() + ", getName : " + tempFile.getName()
								+ ", getOriginalFilename : " + tempFile.getOriginalFilename() + ", getSize : " + tempFile.getSize()
								+ ",getStorageDescription : " + tempFile.getStorageDescription() + "\n");

				String originName = tempFile.getOriginalFilename();
				String ext = "";
				if (originName.lastIndexOf(".") > -1)
					ext = originName.substring(originName.lastIndexOf(".") + 1);

				int seq = (i+1);
				if (!"".equals(originName)) {
					String savingFileName = policy.getName(originName);
					String filePath = saveFolder.getAbsolutePath() + File.separator + savingFileName;
					tempFile.transferTo(new File(filePath));

					SimpleFileVO fileVO = new SimpleFileVO();
					fileVO.setSequence(seq);
					fileVO.setFilePath(pathSuffix + File.separator + savingFileName);
					fileVO.setContentType(tempFile.getContentType());
					fileVO.setOriginalFileName(originName);
					fileVO.setExt(ext);
					fileVO.setSavingFileName(savingFileName);
					fileVO.setFileSize(tempFile.getSize());
					fileVO.setFile(new File(filePath));
					fileList.add(fileVO);
				}
			}
		}
		return fileList;
	}

	/**
	 * [문혁찬 추가 : 2016-08-30] Request로 부터 MultipartFile 객체를 받아 SimpleFileVO에 담아 반환한다. SimpleFileVO는
	 *
	 * @param request as HttpServletRequest
	 * @param jobName as String (ex, ZZ, HR, HA)
	 * @param policy as MultipartFileNamingPolicy
	 * @return List<SimpleFileVO>
	 * @throws Exception
	 */
	public static List<SimpleFileVO> makeFileList(HttpServletRequest request, String jobName, MultipartFileNamingPolicy policy) throws Exception {
		if (jobName == null)
			throw new Exception("파일업로드에 필요한 업무 코드(ex, ZZ, HR, HA) 가 없습니다. ");

		final String biz = jobName;
		final String yyyyMM = new SimpleDateFormat("yyyyMM").format(new Date());
		final String pathSuffix = biz + File.separator + yyyyMM;

		/*
		 * validate request type
		 */
		final MultipartHttpServletRequest multiRequest = (MultipartHttpServletRequest) request;

		/*
		 * extract files
		 */
		final Map<String, MultipartFile> files = multiRequest.getFileMap();

		/*
		 * process files
		 */
		String uploadPath = EgovProperties.getProperty("Globals.FileStorePath");
		File saveFolder = new File(uploadPath + File.separator + pathSuffix);

		// 디렉토리 생성
		if (!saveFolder.exists() || saveFolder.isFile()) {
			saveFolder.mkdirs();
		}

		Iterator<Entry<String, MultipartFile>> itr = files.entrySet().iterator();
		MultipartFile multipartFile;
		List<SimpleFileVO> fileList = new ArrayList<SimpleFileVO>();
		String filePathTmp;
		String filePath;

		try{
			int seq = 0;
			String originName, ext = null;
//			EgSubAPI egSub = new EgSubAPI();
//			egSub.loadAPI();
//			String authCode = "EG";
//			String moduleLicense = EgovProperties.getProperty("Globals.moduleLicense");
			
			String rndNm = System.currentTimeMillis()+"";
			while (itr.hasNext()) {
				Entry<String, MultipartFile> entry = itr.next();
	
				multipartFile = entry.getValue();
				originName = multipartFile.getOriginalFilename();
				if (originName.lastIndexOf(".") > -1)
					ext = originName.substring(originName.lastIndexOf(".") + 1);

				if (!"".equals(originName)) {
					String savingFileName = policy.getName(originName, ++seq);
					
					filePathTmp = saveFolder.getAbsolutePath() + File.separator +"T_"+savingFileName+rndNm;
					filePath = saveFolder.getAbsolutePath() + File.separator +savingFileName+rndNm;
//					egSub.setLicense(authCode, moduleLicense); 
//					egSub.setLogMode(false);   
					multipartFile.transferTo(new File(filePathTmp));
//					if(egSub.getFileType(filePathTmp) != 0){//암호화 파일이면
//						if (egSub.isLicenseCheckState()) {
//							if (egSub.isConfirmLicense()) {
//								egSub.decryptFileEx(filePathTmp, filePath, "SEED", false);
//								
//							}
//						}
//
//					}else{
//						multipartFile.transferTo(new File(filePath));
//					}
					
					File file = new File(filePathTmp);
//					file.delete();
					
					SimpleFileVO fileVO = new SimpleFileVO();
					fileVO.setSequence(seq);
					fileVO.setFilePath(pathSuffix + File.separator + savingFileName+rndNm);
					fileVO.setContentType(multipartFile.getContentType());
					fileVO.setOriginalFileName(originName);
					fileVO.setExt(ext);
					fileVO.setSavingFileName(savingFileName+rndNm);
					fileVO.setFileSize(multipartFile.getSize());
					fileVO.setFile(new File(filePath));
					fileList.add(fileVO);
				}
			}
			
			
			/*int seq = 0;
			String originName, ext = null;
			EgSubAPI egSub = new EgSubAPI();
			egSub.loadAPI();
			String authCode = "EG";
			String moduleLicense = EgovProperties.getProperty("Globals.moduleLicense");
			
			String rndNm = System.currentTimeMillis()+"";
			while (itr.hasNext()) {
				Entry<String, MultipartFile> entry = itr.next();
	
				multipartFile = entry.getValue();
				originName = multipartFile.getOriginalFilename();
				if (originName.lastIndexOf(".") > -1)
					ext = originName.substring(originName.lastIndexOf(".") + 1);

				if (!"".equals(originName)) {
					String savingFileName = policy.getName(originName, ++seq);
					
					filePathTmp = saveFolder.getAbsolutePath() + File.separator +"T_"+savingFileName+rndNm;
					filePath = saveFolder.getAbsolutePath() + File.separator +savingFileName+rndNm;
					egSub.setLicense(authCode, moduleLicense); 
					egSub.setLogMode(false);   
					multipartFile.transferTo(new File(filePathTmp));
					if(egSub.getFileType(filePathTmp) != 0){//암호화 파일이면
						if (egSub.isLicenseCheckState()) {
							if (egSub.isConfirmLicense()) {
								egSub.decryptFileEx(filePathTmp, filePath, "SEED", false);
								
							}
						}

					}else{
						multipartFile.transferTo(new File(filePath));
					}
					
					multipartFile.transferTo(new File(filePath));
					File file = new File(filePathTmp);
					file.delete();
					
					SimpleFileVO fileVO = new SimpleFileVO();
					fileVO.setSequence(seq);
					fileVO.setFilePath(pathSuffix + File.separator + savingFileName+rndNm);
					fileVO.setContentType(multipartFile.getContentType());
					fileVO.setOriginalFileName(originName);
					fileVO.setExt(ext);
					fileVO.setSavingFileName(savingFileName+rndNm);
					fileVO.setFileSize(multipartFile.getSize());
					fileVO.setFile(new File(filePath));
					fileList.add(fileVO);
				}
			}*/
		}catch(Exception ex){
			ex.printStackTrace();
			throw ex;
		}

		return fileList;
	}

	/**
	 * [문혁찬 추가 : 2016-08-30] 업로드된 파일이 파일시스템에 저장되지 않고 DB등에 저장될 경우 이 메소드를 실행하여 파일시스템에 남아 있는 파일을 삭제한다.
	 *
	 * @param fileList
	 */
	public static void cleanupFiles(List<SimpleFileVO> fileList) {
		// delete files from the file system.
		for (int i = 0; i < fileList.size(); i++) {
			SimpleFileVO fileVO = fileList.get(i);
			if (fileVO.isFileDelete()) {
				File file = new File(fileVO.getFilePath());
				file.delete();
			}
		}
	}

	/**
	 * 파일서버에 파일업로드 공통함수
	 *
	 * @param directoryName
	 * @param fileName
	 * @param fileNameId
	 * @param request
	 */
	public static List<SimpleFileVO> setServerFiles(String directoryName, String fileName, String fileNameid, HttpServletRequest request)
					throws Exception {

		PwDefaultFileNamingPolicy policy = new PwDefaultFileNamingPolicy();
		policy.setPrefix(fileName); // 저장파일명01( ex. templateFile-201609121-TEST1 )
		policy.setSuffix(fileNameid); // 저장파일명02 - ID
		// 업로드된 MultipartFile로 부터 SimpleFileVO의 List를 추출한다. (이 과정 이후 파일시스템에 파일이 저장된다.)
		//List<SimpleFileVO> fileList = PwZzSystemFileUtil.getFileList(request, directoryName, policy); // 여러개 처리
		List<SimpleFileVO> fileList = PwZzSystemFileUtil.makeFileList(request, directoryName, policy); // 1개만 처리 됨

		return fileList;
	}

	/**
	 * DB필드에 파일업로드 공통함수
	 *
	 * @param directoryName
	 * @param fileName
	 * @param fileNameId
	 * @param request
	 */
	public static byte[] setDbFiles(String directoryName, String fileName, String fileNameid, HttpServletRequest request) throws Exception {
		byte[] retByte = null;

		List<SimpleFileVO> fileList = PwZzSystemFileUtil.setServerFiles(directoryName, fileName, fileNameid, request);

		int size = fileList.size();
		SimpleFileVO sfVo = null;
		for (int i = 0; i < size; i++) {
			sfVo = fileList.get(i);

			File file = sfVo.getFile();
			if (file.exists()) {
				InputStream in = new FileInputStream(file);
				retByte = IOUtils.toByteArray(in);
				in.close();

				// 파일의 내용을 DB에 저장할 것이므로 파일시스템에 남길 필요없다.
				// vo.setFileDelete(true)를 설정하여 이 메소드 반환된 후 삭제되도록 한다.
				sfVo.setFileDelete(true);
			}
		}

		// 파일시스템에 저장할 필요 없는 파일은 정리한다.
		cleanupFiles(fileList);

		return retByte;
	}

	public static void filDown(HttpServletRequest request,
			HttpServletResponse response, String filePath, String realFilNm,
			String viewFileNm) throws IOException {

		File file = new File( filePath + realFilNm);
		if (file.exists() && file.isFile()) {
			response.setContentType("application/octet-stream; charset=utf-8");
			response.setContentLength((int) file.length());
			String browser = getBrowser(request);
			String disposition = getDisposition(viewFileNm, browser);
			response.setHeader("Content-Disposition", disposition);
			response.setHeader("Content-Transfer-Encoding", "binary");
			OutputStream out = response.getOutputStream();
			FileInputStream fis = null;
			fis = new FileInputStream(file);
			FileCopyUtils.copy(fis, out);
			if (fis != null)
				fis.close();
			out.flush();
			out.close();
		}
	}

	@SuppressWarnings("resource")
	public static void filInput(HttpServletRequest request,
			HttpServletResponse response, String filePath, String realFilNm,
			String viewFileNm) throws IOException {

		File file = new File( filePath + realFilNm);
		if (file.exists() && file.isFile()) {
			response.setContentType("application/octet-stream; charset=utf-8");
			response.setContentLength((int) file.length());
			String browser = getBrowser(request);
			String disposition = getDisposition(viewFileNm, browser);
			ServletOutputStream out = response.getOutputStream();
			FileInputStream fis = null;
			fis = new FileInputStream(file);
		    int binaryRead;

		    while ((binaryRead = fis.read()) != -1)	{
		        out.write(binaryRead);
		    }
		}
	}

	private static String getBrowser(HttpServletRequest request) {
		String header = request.getHeader("User-Agent");
		if (header.indexOf("MSIE") > -1 || header.indexOf("Trident") > -1)
			return "MSIE";
		else if (header.indexOf("Chrome") > -1)
			return "Chrome";
		else if (header.indexOf("Opera") > -1)
			return "Opera";
		return "Firefox";
	}

	private static String getDisposition(String filename, String browser)
			throws UnsupportedEncodingException {
		String dispositionPrefix = "attachment;filename=";
		String encodedFilename = null;
		if (browser.equals("MSIE")) {
			encodedFilename = URLEncoder.encode(filename, "UTF-8").replaceAll(
					"\\+", "%20");
		} else if (browser.equals("Firefox")) {
			encodedFilename = "\""
					+ new String(filename.getBytes("UTF-8"), "8859_1") + "\"";
		} else if (browser.equals("Opera")) {
			encodedFilename = "\""
					+ new String(filename.getBytes("UTF-8"), "8859_1") + "\"";
		} else if (browser.equals("Chrome")) {
			StringBuffer sb = new StringBuffer();
			for (int i = 0; i < filename.length(); i++) {
				char c = filename.charAt(i);
				if (c > '~') {
					sb.append(URLEncoder.encode("" + c, "UTF-8"));
				} else {
					sb.append(c);
				}
			}
			encodedFilename = sb.toString();
		}
		return dispositionPrefix + encodedFilename;
	}

   /**
   * 파일서버에 파일업로드 공통함수(여러건)
   *
   * @param directoryName
   * @param fileName
   * @param fileNameId
   * @param request
   */
   public static List<SimpleFileVO> mulitFileSave(String directoryName, String fileName, String fileNameid, HttpServletRequest request)
               throws Exception {
     PwDefaultFileNamingPolicy policy = new PwDefaultFileNamingPolicy();
     policy.setPrefix(fileName); // 저장파일명01( ex. templateFile-201609121-TEST1 )
     policy.setSuffix(fileNameid); // 저장파일명02 - ID
     // 업로드된 MultipartFile로 부터 SimpleFileVO의 List를 추출한다. (이 과정 이후 파일시스템에 파일이 저장된다.)
     List<SimpleFileVO> fileList = PwZzSystemFileUtil.getFileList(request, directoryName, policy); // 여러개 처리
      return fileList;
   }
   
   

	   
	public static void filAllDown(HttpServletRequest request, HttpServletResponse response, String filePath, String[] realFilNm, String[] viewFileNm) 
			throws IOException {
        
	String zipFile = "C:/Download file.zip";		//ZIP 압축 파일명
	
	try{

		// ZipOutputStream / FileOutputStream set
	    FileOutputStream fout = new FileOutputStream(zipFile);
	    ZipOutputStream zout = new ZipOutputStream(fout);

	    for(int k=0; k <= realFilNm[k].length(); k++){
	    	

	        //압축 파일내 이름 설정 
	        ZipEntry zipEntry = new ZipEntry(viewFileNm[k]);   // 파일명 설정
	        zout.putNextEntry(zipEntry);

	        //파일경로
	        FileInputStream fin = new FileInputStream("C:\\temp\\" + realFilNm[k]);
	        
	        		
	        byte[] buffer = new byte[1024];
	        int length;

	        // input file을 1024바이트 buffer 설정
	        while((length = fin.read(buffer)) > 0){
	            zout.write(buffer, 0, length);
	        }

	        zout.closeEntry();
	        fin.close();
	    }

	    zout.close();

	    response.setContentType("application/zip");
	    response.addHeader("Content-Disposition", "attachment; filename=" + zipFile);

	    FileInputStream fis=new FileInputStream(zipFile);
	    BufferedInputStream bis=new BufferedInputStream(fis);
	    ServletOutputStream so=response.getOutputStream();
	    BufferedOutputStream bos=new BufferedOutputStream(so);

	    byte[] data=new byte[2048];
	    int input=0;

	    while((input=bis.read(data))!=-1){
	        bos.write(data,0,input);
	        bos.flush();
	    }

	    if(bos!=null) bos.close();
	    if(bis!=null) bis.close();
	    if(so!=null) so.close();
	    if(fis!=null) fis.close();

	    } catch(IOException ioe){
	    	
	    }
	}
}
